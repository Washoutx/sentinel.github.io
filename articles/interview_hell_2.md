---
layout: default
---

## What is Perfect Forwarding/Forwarding Reference and std::move vs std::forward?

A Forwarding Reference (also known as a Universal Reference) is a function parameter of type T&& in a template function, where T is a template parameter deduced from the argument. This definition allows a function such as foo() to be called with either an lvalue or an rvalue object.

```cpp
struct A
{  
    void foo() & // definition for L-value object
    {
        std::cout << "void foo() &\n";
    }
    void foo() && // definition for R-value object
    {
        std::cout << "void foo() &&\n";
    }

};

template <typename T>
void foo(T&& obj) // Forwarding Reference (Universal Reference)
{
    obj.foo();
};

int main()
{
    A a;
    foo(a);
    foo(std::move(a));

    return 0;
}
```
```
void foo() &
void foo() &
```
Note: struct A has two overloaded methods Which one is called depends on the value category of the argument.
As you can see, even if I use `std::move`, inside the `foo()` function the parameter obj is still an `lvalue`. This makes sense, because function parameters always have names, and named objects are `lvalues` (`T&& var` - is not R-value with name but R-Value reference). So how can we get the correct value type of the original argument? We need to use `std::forward`. This technique is called perfect forwarding.

```cpp
struct A
{  
    void foo() & // definition for L-value object
    {
        std::cout << "void foo() &\n";
    }
    void foo() && // definition for R-value object
    {
        std::cout << "void foo() &&\n";
    }

};

template <typename T>
void foo(T&& obj) // Forwarding Reference (Universal Reference)
{
    std::forward<T>(obj).foo(); // Perfect Forwarding
};

int main()
{
    A a;
    foo(a);
    foo(std::move(a));

    return 0;
}
```
```
void foo() &
void foo() &&
```

What do `std::forward` and `std::move` actually do under the hood?
They are essentially just static casts to `T&&`.

But first we need to show how forwarding reference impacts template specialization generation (you can use [cppinsights](https://cppinsights.io) to check that).
Lets analyse the custom `std::move` implementation:
```cpp
template<typename T>
std::remove_reference_t<T> && my_move(T && arg)
{
  return static_cast<std::remove_reference_t<T> &&>(arg);
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
std::remove_reference_t<int &> && my_move<int &>(int & arg)
{
  return static_cast<std::remove_reference_t<int &> &&>(arg);
}
#endif

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
std::remove_reference_t<int> && my_move<int>(int && arg)
{
  return static_cast<std::remove_reference_t<int> &&>(arg);
}
#endif

int main()
{
  int i = 10;
  my_move(i);
  my_move(10);
  return 0;
}
```

For the L-value there is specialization `my_move<int &>(int & arg)` but for R-value just `my_move<int>(int && arg)`. Notice that the template argument `T` is just `int` for the R-value and `int&` for the L-value.
This is special behavior for forwarding reference. Another thing is how to match specific reference when `T` in implementation has additional references.
Standard defines this as `Rules of reference collapsing`:
```
& + &   -> &
& + &&  -> &
&& + &  -> &
&& + && -> &&
```
This is why `std::remove_reference_t<T>` is needed for return and casting type. Let's check what's wrong can happen without remove reference.

Let's keep it simple and check what happen if I cast L-value to R-value using custom my_move:
```cpp
template<typename T>
T && my_move(T && arg)
{
  return static_cast<T &&>(arg);
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
int & my_move<int &>(int & arg)
{
  return static_cast<int &>(arg);
}
#endif

int main()
{
  int i = 10;
  my_move(i);
  return 0;
}
```
Ok so why in `int & my_move<int &>(int & arg)` return value and casting type are L-value reference? Because of reference collapsing.
As you can see in template specialization `T=int&` (because `my_move<int &>`). 
So according to the rules `T(int&)` argument against `T&&` in parameter and return value collapsed to `T&`
```
& + &&  -> &
```
In the implementation with the `std::remove_reference_t<T>` reference collapsing doesn't occur because all the references are removed and syntax is reduced to `T` so compiler just add `&&` to `T`.
This is very confusing concept when you face forwarding reference and reference collapsing rules at the same time.
Let's check custom `std::forward` using our first example:

```cpp
struct A
{
  inline void foo() &
  {
    std::operator<<(std::cout, "void foo() &\n");
  }
  
  inline void foo() &&
  {
    std::operator<<(std::cout, "void foo() &&\n");
  }
};

template<typename T>
T && my_forward(std::remove_reference_t<T> & arg)
{
  return static_cast<T &&>(arg);
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
A & my_forward<A &>(std::remove_reference_t<A &> & arg)
{
  return static_cast<A &>(arg);
}
#endif

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
A && my_forward<A>(std::remove_reference_t<A> & arg)
{
  return static_cast<A &&>(arg);
}
#endif

template<typename T>
void foo(T && obj)
{
  my_forward<T>(obj).foo();
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<A &>(A & obj)
{
  my_forward<A &>(obj).foo();
}
#endif

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<A>(A && obj)
{
  my_forward<A>(obj).foo();
}
#endif

int main()
{
  A a;
  foo(a);
  foo(std::move(a));
  return 0;
}
```
```
void foo() &
void foo() &&
```
As we said earlier `foo()` doesn't lost an information of the underyling type. For R-value there is `my_forward<A>(obj)` and for the L-value there is
`my_forward<A &>(obj)`. So let's match it with the `my_forward` definition. It uses reference collapsing rules in casting and return value. Thanks to that we returns L-value or R-value reference.

You can wonder why we need to declare template type explicitly `my_forward<A>(obj)` but `my_move(i)` works without that. It is make on purpose and it is related to something called `non-deduced context` of `std::remove_reference_t` in the parameter of `my_foward`. (more details: [Template argument deduction](https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.call) or [stackoverflow](https://stackoverflow.com/questions/70159423/forward-with-remove-reference-in-template-function-parameter-type)). It push the user to specify template type of `my_forward`. Thanks to that we avoid issues like in the following example:
```cpp
struct A
{
  inline void foo() &
  {
    std::operator<<(std::cout, "void foo() &\n");
  }
  
  inline void foo() &&
  {
    std::operator<<(std::cout, "void foo() &&\n");
  }
};

template<typename T>
T && my_forward(T & arg)
{
  return static_cast<T &&>(arg);
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
A && my_forward<A>(A & arg)
{
  return static_cast<A &&>(arg);
}
#endif

template<typename T>
void foo(T && obj)
{
  my_forward(obj).foo();
}

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<A &>(A & obj)
{
  my_forward(obj).foo();
}
#endif

/* Following code is generated by the compiler */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
void foo<A>(A && obj)
{
  my_forward(obj).foo();
}
#endif

int main()
{
  A a;
  foo(a);
  foo(std::move(a));
  return 0;
}

```
```
void foo() &&
void foo() &&
```
You can now compare `my_forward` specialization with and without `std::remove_reference_t`. You can notice only one specialization because T is not implicitly provided. What the difference?
When you manually write `my_foward<T>` then you are forwarding underyling type of `T` which is `T` or `T&`.
So compiler can specialize two different definitions of `my_forward`. So to summarize:

1) Using `my_forward(obj).foo()`
```cpp
template<>
A && my_forward<A>(A & arg)
{
  return static_cast<A &&>(arg);
}
```
2) Using `my_forward<T>(obj).foo()`
```cpp
template<>
A & my_forward<A &>(std::remove_reference_t<A &> & arg)
{
  return static_cast<A &>(arg);
}
template<>
A && my_forward<A>(std::remove_reference_t<A> & arg)
{
  return static_cast<A &&>(arg);
}
```

[back](/)